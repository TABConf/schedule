<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes" />
    <title>TABConf Schedule</title>
    <style>
        :root {
            --bg: #0f1115;
            --card: #171a21;
            --muted: #aab2c0;
            --text: #e6e9ef;
            --accent: #4da3ff;
            --border: #2a2f3a;
        }

        html,
        body {
            background: var(--bg);
            color: var(--text);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            margin: 0;
            padding: 0;
        }

        .wrap {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px 16px 48px;
        }

        header {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }

        h1 {
            font-size: 24px;
            margin: 0 0 4px 0;
        }

        .filters {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
            background: var(--card);
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: 12px;
        }

        .filters label {
            font-size: 14px;
            color: var(--muted);
        }

        select {
            background: #0d0f14;
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 8px 10px;
            font-size: 14px;
        }

        .legend {
            font-size: 12px;
            color: var(--muted);
            margin-left: auto;
        }

        .day-card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            margin-top: 18px;
        }

        .day-title {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            background: #11141a;
        }

        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            table-layout: fixed;
        }

        thead th {
            position: sticky;
            top: 0;
            background: #11141a;
            z-index: 1;
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            font-size: 13px;
            padding: 10px;
        }

        tbody td,
        tbody th {
            border-bottom: 1px solid var(--border);
            vertical-align: top;
            padding: 8px;
            font-size: 13px;
            word-wrap: break-word;
        }

        tbody th.timecell {
            color: var(--muted);
            width: 90px;
            font-weight: 500;
            white-space: nowrap;
        }

        tbody td {
            position: static;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .slot {
            border: 1px solid transparent;
            border-radius: 10px;
            padding: 8px;
            backdrop-filter: saturate(120%);
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .slot h4 {
            margin: 0 0 6px 0;
            font-size: 14px;
            line-height: 1.25;
        }

        .slot .meta {
            font-size: 12px;
            color: var(--muted);
        }

        .badges {
            display: inline-flex;
            gap: 6px;
            flex-wrap: wrap;
            margin: 6px 0 0 0;
        }

        .badge {
            border: 1px solid var(--border);
            background: rgba(255, 255, 255, 0.05);
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 999px;
        }

        a {
            color: var(--accent);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        @media (max-width:640px) {
            tbody th.timecell {
                width: 68px;
                white-space: normal;
                line-height: 1.2;
                font-size: 12px;
                text-align: right;
            }
        }
    </style>
</head>

<body>
    <div class="wrap">
        <header>
            <div>
                <h1>TABConf Schedule</h1>
                <div class="filters">
                    <label for="dayFilter">Day:</label>
                    <select id="dayFilter">
                        <option value="all">All days</option>
                        <option value="D0 - Oct 12">D0 - Oct 12</option>
                        <option value="D1 - Oct 13">D1 - Oct 13</option>
                        <option value="D2 - Oct 14">D2 - Oct 14</option>
                        <option value="D3 - Oct 15">D3 - Oct 15</option>
                        <option value="D4 - Oct 16">D4 - Oct 16</option>
                    </select>

                    <label for="typeFilter">Type:</label>
                    <select id="typeFilter">
                        <option value="all">All types</option>
                        <option>Workshop</option>
                        <option>Talk</option>
                        <option>Panel</option>
                        <option>Debate</option>
                        <option>Unrecorded</option>
                        <option>Beginner</option>
                        <option>Advanced</option>
                        <option>Builder Days Project</option>
                        <option>Events</option>
                    </select>

                    <div class="legend">
                        Select filters to refine. Days without matches are hidden.
                        <a href="https://github.com/orgs/TABConf/projects/9" target="_blank"
                            rel="noopener noreferrer">See the project schedule on Github</a>.
                    </div>
                </div>
            </div>
        </header>

        <div id="days"></div>
    </div>

    <script>
        const DAY_LABELS = {
            'D0 - Oct 12': 'Day 0 - October 12',
            'D1 - Oct 13': 'Day 1 - October 13',
            'D2 - Oct 14': 'Day 2 - October 14',
            'D3 - Oct 15': 'Day 3 - October 15',
            'D4 - Oct 16': 'Day 4 - October 16'
        };

        const DAY_COLUMNS = {
            'D0 - Oct 12': ['Time', 'General'], // Day 0 single column
            'D1 - Oct 13': ['Time', 'Workshop Room 1', 'Workshop Room 2', 'General'],
            'D2 - Oct 14': ['Time', 'Workshop Room 1', 'Workshop Room 2', 'General'],
            'D3 - Oct 15': ['Time', 'Socratic Bitdevs', 'Main Stage', 'General'],
            'D4 - Oct 16': ['Time', 'Socratic Bitdevs', 'Main Stage', 'General']
        };

        const DAY_KEYS_IN_ORDER = ['D0 - Oct 12', 'D1 - Oct 13', 'D2 - Oct 14', 'D3 - Oct 15', 'D4 - Oct 16'];
        const ACCEPTED_LABELS = new Set(['accepted', 'confirmed']);
        const norm = s => String(s || '').trim().toLowerCase();

        function hashColor(str) { let h = 5381; for (let i = 0; i < str.length; i++)h = ((h << 5) + h) + str.charCodeAt(i); const hex = (h >>> 0).toString(16).padStart(8, '0'); return `#${hex.slice(-6)}`; }
        function hexToRgb(hex) { const v = hex.replace('#', ''); return { r: parseInt(v.slice(0, 2), 16), g: parseInt(v.slice(2, 4), 16), b: parseInt(v.slice(4, 6), 16) }; }
        function computeColorFromLabels(ev) {
            const names = (ev.labels || []).map(l => l && l.name ? l.name : '').filter(Boolean).map(x => x.trim()).filter(x => !ACCEPTED_LABELS.has(x.toLowerCase())).sort((a, b) => a.localeCompare(b));
            const key = names.join('|') || 'default'; const hex = hashColor(key); const { r, g, b } = hexToRgb(hex);
            return { rgbaBg: `rgba(${r}, ${g}, ${b}, 0.18)`, border: `rgba(${r}, ${g}, ${b}, 0.45)` };
        }

        // ONLY startTime / endTime are used
        function parseTime(t) {
            if (!t) return null;
            const s = String(t).trim().toUpperCase().replace(/\s/g, ''); // allow "11:30 AM" or "11:30AM"
            const m = s.match(/^(\d{1,2})(?::(\d{2}))?(AM|PM)$/); // require AM/PM for clarity
            if (!m) return null;
            let hour = parseInt(m[1], 10); let min = m[2] ? parseInt(m[2], 10) : 0; const ap = m[3];
            if (ap === 'PM' && hour < 12) hour += 12; if (ap === 'AM' && hour === 12) hour = 0;
            return { h: hour, m: min, minutes: hour * 60 + min };
        }
        function fmtTime(mins) { const h24 = Math.floor(mins / 60); const m = mins % 60; const ampm = h24 >= 12 ? 'PM' : 'AM'; let h = h24 % 12; if (h === 0) h = 12; return `${h}:${String(m).padStart(2, '0')} ${ampm}`; }

        function normalizeSingleDayKey(dayValue) {
            const s = norm(dayValue);
            if (s.startsWith('day 0')) return 'D0 - Oct 12';
            if (s.startsWith('day 1')) return 'D1 - Oct 13';
            if (s.startsWith('day 2')) return 'D2 - Oct 14';
            if (s.startsWith('day 3')) return 'D3 - Oct 15';
            if (s.startsWith('day 4')) return 'D4 - Oct 16';
            return null;
        }

        // "All Days" -> D1..D4; "Day X & Y" -> [X,Y]; "Day N" -> [N]; else []
        function expandItemToDays(item) {
            const s = norm(item.day);
            if (s === 'all days' || s === 'alldays' || s === 'all') return ['D1 - Oct 13', 'D2 - Oct 14', 'D3 - Oct 15', 'D4 - Oct 16']; // never Day 0
            const m = s.match(/^day\s*([0-4])\s*(?:&|and)\s*([0-4])$/);
            if (m) {
                const a = Math.min(+m[1], +m[2]); const b = Math.max(+m[1], +m[2]);
                return [normalizeSingleDayKey(`Day ${a}`), normalizeSingleDayKey(`Day ${b}`)].filter(Boolean);
            }
            const single = normalizeSingleDayKey(item.day);
            return single ? [single] : [];
        }
        function isMultiOrAllDayItem(item) {
            const days = expandItemToDays(item);
            if (days.length > 1) return true;
            const s = norm(item.day);
            return (s === 'all days' || s === 'alldays' || s === 'all');
        }

        // Robust village -> column mapper; fall back to General
        function mapToValidColumn(dayKey, village, colNames) {
            if (dayKey === 'D0 - Oct 12') return 'General'; // Day 0: single column
            const v = norm(village).replace(/\s+/g, '');
            let out = 'General';
            if (dayKey === 'D3 - Oct 15' || dayKey === 'D4 - Oct 16') {
                if (/main(stage)?/.test(v)) out = 'Main Stage';
                else if (/(bitdevs|socratic)/.test(v)) out = 'Socratic Bitdevs';
            } else {
                if (/(workshop)?room?1|wr1|workshop1/.test(v)) out = 'Workshop Room 1';
                else if (/(workshop)?room?2|wr2|workshop2/.test(v)) out = 'Workshop Room 2';
            }
            if (!colNames.includes(out)) out = colNames.includes('General') ? 'General' : colNames[0];
            return out;
        }

        async function load() {
            const res = await fetch('data/schedule.json', { cache: 'no-store' });
            const all = await res.json();

            const daySel = document.getElementById('dayFilter');
            const typeSel = document.getElementById('typeFilter');
            const daysEl = document.getElementById('days');

            function eventMatchesType(ev, typeVal) {
                if (typeVal === 'all') return true;
                const names = (ev.labels || []).map(l => (l.name || '').toLowerCase());
                return names.includes(typeVal.toLowerCase());
            }

            function render() {
                const dayVal = daySel.value;
                const typeVal = typeSel.value;

                // Build per-day buckets using expansion rules
                const byDay = new Map();
                for (const item of all) {
                    const dayKeys = expandItemToDays(item);
                    if (!dayKeys.length) continue;
                    for (const dk of dayKeys) {
                        if (!DAY_COLUMNS[dk]) continue;
                        if (dayVal !== 'all' && dk !== dayVal) continue;
                        if (!eventMatchesType(item, typeVal)) continue;
                        if (!byDay.has(dk)) byDay.set(dk, []);
                        byDay.get(dk).push(item);
                    }
                }

                daysEl.innerHTML = '';

                for (const dayKey of DAY_KEYS_IN_ORDER) {
                    const list = byDay.get(dayKey) || [];
                    if (!list.length) continue;

                    const cols = DAY_COLUMNS[dayKey];
                    const colNames = cols.slice(1);

                    // Split per your rules
                    const regularItems = [];
                    const specialGeneral = [];
                    for (const ev of list) {
                        if (isMultiOrAllDayItem(ev)) specialGeneral.push(ev);
                        else regularItems.push(ev);
                    }

                    // Build time ticks strictly from startTime/endTime
                    const times = new Set();
                    let minStart = Infinity, maxEnd = -Infinity;
                    const addBoundsFrom = (ev) => {
                        const s = parseTime(ev.startTime);
                        const e = parseTime(ev.endTime);
                        if (s) { times.add(s.minutes); minStart = Math.min(minStart, s.minutes); }
                        if (e) { times.add(e.minutes); maxEnd = Math.max(maxEnd, e.minutes); }
                    };
                    for (const ev of regularItems) addBoundsFrom(ev);
                    for (const ev of specialGeneral) addBoundsFrom(ev);

                    // If nothing had valid times, skip this day
                    if (!isFinite(minStart) || !isFinite(maxEnd)) continue;

                    const sortedTicks = Array.from(times).sort((a, b) => a - b);
                    const toIdx = (mins) => sortedTicks.findIndex(x => x === mins);

                    // Bucket regulars into columns
                    const byCol = new Map(colNames.map(n => [n, []]));
                    for (const ev of regularItems) {
                        const target = mapToValidColumn(dayKey, ev.village, colNames);
                        byCol.get(target).push(ev);
                    }

                    // Build groups (identical span) per column
                    const groupsByCol = new Map();
                    for (const [col, arr] of byCol.entries()) {
                        const gmap = new Map();
                        for (const ev of arr) {
                            const s = parseTime(ev.startTime);
                            const e = parseTime(ev.endTime);
                            if (!s || !e) continue;
                            const si = toIdx(s.minutes), ei = toIdx(e.minutes);
                            if (si === -1 || ei === -1 || ei <= si) continue;
                            const key = `${si}-${ei}`;
                            if (!gmap.has(key)) gmap.set(key, { si, ei, items: [] });
                            gmap.get(key).items.push(ev);
                        }
                        const groups = Array.from(gmap.values()).sort((a, b) => a.si - b.si || a.ei - b.ei);
                        groupsByCol.set(col, groups);
                    }

                    // Table DOM
                    const card = document.createElement('div');
                    card.className = 'day-card';
                    card.innerHTML = `<div class="day-title">${DAY_LABELS[dayKey] || dayKey}</div>`;

                    const table = document.createElement('table');
                    const thead = document.createElement('thead');
                    const trh = document.createElement('tr');
                    for (const head of cols) { const th = document.createElement('th'); th.textContent = head; trh.appendChild(th); }
                    thead.appendChild(trh); table.appendChild(thead);
                    const tbody = document.createElement('tbody');

                    // Track occupancy for rowspans
                    const occupancy = new Map(colNames.map(n => [n, Array(sortedTicks.length - 1).fill(false)]));

                    for (let r = 0; r < sortedTicks.length - 1; r++) {
                        const row = document.createElement('tr');

                        const tcell = document.createElement('th');
                        tcell.className = 'timecell';
                        const compact = matchMedia('(max-width: 640px)').matches;
                        tcell.innerHTML = compact ? `${fmtTime(sortedTicks[r])}<br>${fmtTime(sortedTicks[r + 1])}` : `${fmtTime(sortedTicks[r])} - ${fmtTime(sortedTicks[r + 1])}`;
                        row.appendChild(tcell);

                        for (const col of colNames) {
                            if (occupancy.get(col)[r]) continue; // covered by a rowspan

                            const td = document.createElement('td');

                            // regular group starting here?
                            const group = (groupsByCol.get(col) || []).find(g => g.si === r && !g.used);
                            if (group) {
                                const span = group.ei - group.si;
                                for (let k = r; k < group.ei; k++) occupancy.get(col)[k] = true;

                                const isSingle = group.items.length === 1;
                                for (const ev of group.items) {
                                    const { rgbaBg, border } = computeColorFromLabels(ev);
                                    const box = document.createElement('div');
                                    box.className = 'slot';
                                    box.style.background = rgbaBg;
                                    box.style.borderColor = border;
                                    box.style.borderStyle = 'solid';
                                    box.style.marginBottom = '8px';
                                    if (isSingle) box.style.flex = '1';

                                    const title = document.createElement('h4');
                                    const tlink = document.createElement('a');
                                    tlink.href = ev.url || '#'; tlink.target = '_blank'; tlink.rel = 'noopener noreferrer';
                                    tlink.textContent = ev.title || 'Untitled';
                                    title.appendChild(tlink); box.appendChild(title);

                                    const meta = document.createElement('div');
                                    meta.className = 'meta';
                                    const assignees = (ev.assignees || '')
                                        .split(',').map(s => s.trim()).filter(Boolean)
                                        .map(u => `<a href="https://github.com/${u}" target="_blank" rel="noopener noreferrer">@${u}</a>`)
                                        .join(' ');
                                    meta.innerHTML = assignees;
                                    box.appendChild(meta);

                                    const cleanLabels = (ev.labels || []).filter(l => l && l.name && !ACCEPTED_LABELS.has(l.name.toLowerCase()));
                                    if (cleanLabels.length) {
                                        const badges = document.createElement('div'); badges.className = 'badges';
                                        cleanLabels.forEach(l => { const b = document.createElement('span'); b.className = 'badge'; b.textContent = l.name; badges.appendChild(b); });
                                        box.appendChild(badges);
                                    }

                                    td.appendChild(box);
                                }
                                if (td.lastElementChild) td.lastElementChild.style.marginBottom = '0';
                                td.setAttribute('rowspan', String(span));
                                group.used = true;
                            }

                            row.appendChild(td);
                        }

                        tbody.appendChild(row);
                    }

                    // SPECIAL: place multi/all-day items into General with “next available” stacking
                    if (colNames.includes('General') && specialGeneral.length) {
                        const generalGroups = [];
                        for (const ev of specialGeneral) {
                            const s = parseTime(ev.startTime);
                            const e = parseTime(ev.endTime);
                            if (!s || !e) continue;
                            const si = toIdx(s.minutes), ei = toIdx(e.minutes);
                            if (si === -1 || ei === -1 || ei <= si) continue;

                            // find the earliest row >= si that is unoccupied in General
                            const genOcc = occupancy.get('General');
                            let placeStart = si;
                            while (placeStart < ei && genOcc[placeStart]) placeStart++; // shift down if blocked
                            if (placeStart >= ei) continue; // no room

                            // mark occupancy from placeStart..ei
                            for (let k = placeStart; k < ei; k++) genOcc[k] = true;
                            generalGroups.push({ si: placeStart, ei, items: [ev] });
                        }

                        // Inject these into the DOM (walk rows and append cells with rowspan)
                        for (const g of generalGroups) {
                            const span = g.ei - g.si;
                            // find tbody row at index g.si (skip header row)
                            const row = tbody.children[g.si];
                            if (!row) continue;

                            // find the insertion point (after time cell, find correct td slot for General)
                            const idxOfGeneral = DAY_COLUMNS[dayKey].indexOf('General'); // header index
                            if (idxOfGeneral === -1) continue;

                            // Count how many cells already exist before “General” in this row (time header + earlier cols minus any skipped due to rowspans)
                            let insertBefore = null;
                            let seen = 0;
                            for (const node of row.children) {
                                // th(time) counts as first header column
                                if (node.tagName === 'TH') { seen++; continue; }
                                // td corresponds to next visible column slot
                                seen++;
                                if (seen === idxOfGeneral + 1) { insertBefore = node; break; }
                            }

                            const td = document.createElement('td');
                            td.style.display = 'flex'; td.style.flexDirection = 'column';

                            const ev = g.items[0];
                            const { rgbaBg, border } = computeColorFromLabels(ev);
                            const box = document.createElement('div');
                            box.className = 'slot';
                            box.style.background = rgbaBg; box.style.borderColor = border; box.style.borderStyle = 'solid';
                            box.style.flex = '1';

                            const title = document.createElement('h4');
                            const tlink = document.createElement('a');
                            tlink.href = ev.url || '#'; tlink.target = '_blank'; tlink.rel = 'noopener noreferrer';
                            tlink.textContent = ev.title || 'Untitled';
                            title.appendChild(tlink); box.appendChild(title);

                            const meta = document.createElement('div'); meta.className = 'meta';
                            const assignees = (ev.assignees || '')
                                .split(',').map(s => s.trim()).filter(Boolean)
                                .map(u => `<a href="https://github.com/${u}" target="_blank" rel="noopener noreferrer">@${u}</a>`)
                                .join(' ');
                            meta.innerHTML = assignees; box.appendChild(meta);

                            const cleanLabels = (ev.labels || []).filter(l => l && l.name && !ACCEPTED_LABELS.has(l.name.toLowerCase()));
                            if (cleanLabels.length) {
                                const badges = document.createElement('div'); badges.className = 'badges';
                                cleanLabels.forEach(l => { const b = document.createElement('span'); b.className = 'badge'; b.textContent = l.name; badges.appendChild(b); });
                                box.appendChild(badges);
                            }

                            td.appendChild(box);
                            td.setAttribute('rowspan', String(span));

                            if (insertBefore) row.insertBefore(td, insertBefore);
                            else row.appendChild(td);
                        }
                    }

                    table.appendChild(tbody);
                    card.appendChild(table);
                    daysEl.appendChild(card);
                }

                if (!daysEl.children.length) {
                    daysEl.innerHTML = '<div class="day-card"><div class="day-title">No matching sessions</div></div>';
                }
            }

            daySel.addEventListener('change', render);
            typeSel.addEventListener('change', render);
            render();
        }

        load().catch(err => {
            document.getElementById('days').innerHTML = `<div class="day-card"><div class="day-title">Error loading schedule</div><div style="padding:12px;color:#f99;">${String(err)}</div></div>`;
            console.error(err);
        });
    </script>
</body>

</html>
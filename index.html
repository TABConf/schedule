<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes" />
    <title>TABConf Schedule (Simple)</title>
    <style>
        :root {
            --bg: #0f1115;
            --card: #171a21;
            --muted: #aab2c0;
            --text: #e6e9ef;
            --accent: #4da3ff;
            --border: #2a2f3a;
        }

        html,
        body {
            background: var(--bg);
            color: var(--text);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            margin: 0;
            padding: 0;
        }

        .wrap {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px 16px 48px;
        }

        header {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }

        h1 {
            font-size: 24px;
            margin: 0 0 4px 0;
        }

        .filters {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
            background: var(--card);
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: 12px;
        }

        .filters label {
            font-size: 14px;
            color: var(--muted);
        }

        select {
            background: #0d0f14;
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 8px 10px;
            font-size: 14px;
        }

        .legend {
            font-size: 12px;
            color: var(--muted);
            margin-left: auto;
        }

        .day-card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            margin-top: 18px;
        }

        .day-title {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            background: #11141a;
        }

        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            table-layout: fixed;
        }

        thead th {
            position: sticky;
            top: 0;
            background: #11141a;
            z-index: 1;
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            font-size: 13px;
            padding: 10px;
        }

        tbody td,
        tbody th {
            border-bottom: 1px solid var(--border);
            vertical-align: top;
            padding: 8px;
            font-size: 13px;
            word-wrap: break-word;
        }

        tbody th.timecell {
            color: var(--muted);
            width: 90px;
            font-weight: 500;
            white-space: nowrap;
        }

        /* keep <td> as table cells; stack cards inside with a simple wrapper */
        .stack {
            display: flex;
            flex-direction: column;
            gap: 8px;
            height: 100%;
        }

        .slot {
            border: 1px solid transparent;
            border-radius: 10px;
            padding: 8px;
            backdrop-filter: saturate(120%);
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .slot.single {
            height: 100%;
        }

        /* single item fills the whole rowspan cell */
        .slot h4 {
            margin: 0 0 6px 0;
            font-size: 14px;
            line-height: 1.25;
        }

        .slot .meta {
            font-size: 12px;
            color: var(--muted);
        }

        .badges {
            display: inline-flex;
            gap: 6px;
            flex-wrap: wrap;
            margin: 6px 0 0 0;
        }

        .badge {
            border: 1px solid var(--border);
            background: rgba(255, 255, 255, 0.05);
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 999px;
        }

        a {
            color: var(--accent);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        @media (max-width:640px) {
            tbody th.timecell {
                width: 68px;
                white-space: normal;
                line-height: 1.2;
                font-size: 12px;
                text-align: right;
            }
        }
    </style>
</head>

<body>
    <div class="wrap">
        <header>
            <div>
                <h1>TABConf Schedule</h1>
                <div class="filters">
                    <label for="dayFilter">Day:</label>
                    <select id="dayFilter">
                        <option value="all">All days</option>
                        <option value="D0 - Oct 12">D0 - Oct 12</option>
                        <option value="D1 - Oct 13">D1 - Oct 13</option>
                        <option value="D2 - Oct 14">D2 - Oct 14</option>
                        <option value="D3 - Oct 15">D3 - Oct 15</option>
                        <option value="D4 - Oct 16">D4 - Oct 16</option>
                    </select>

                    <label for="typeFilter">Type:</label>
                    <select id="typeFilter">
                        <option value="all">All types</option>
                        <option>Workshop</option>
                        <option>Talk</option>
                        <option>Panel</option>
                        <option>Debate</option>
                        <option>Unrecorded</option>
                        <option>Beginner</option>
                        <option>Advanced</option>
                        <option>Builder Days Project</option>
                        <option>Events</option>
                    </select>

                    <div class="legend">
                        Everything is rendered generically from start/end times.
                        <a href="https://github.com/orgs/TABConf/projects/9" target="_blank"
                            rel="noopener noreferrer">See the project schedule on Github</a>.
                    </div>
                </div>
            </div>
        </header>

        <div id="days"></div>
    </div>

    <script>
        /* === Simple constants === */
        const DAY_LABELS = {
            'D0 - Oct 12': 'Day 0 - October 12',
            'D1 - Oct 13': 'Day 1 - October 13',
            'D2 - Oct 14': 'Day 2 - October 14',
            'D3 - Oct 15': 'Day 3 - October 15',
            'D4 - Oct 16': 'Day 4 - October 16'
        };
        const DAY_ORDER = ['D0 - Oct 12', 'D1 - Oct 13', 'D2 - Oct 14', 'D3 - Oct 15', 'D4 - Oct 16'];
        const DAY_COLUMNS = {
            'D0 - Oct 12': ['Time', 'General'], // keep D0 one lane (still generic)
            'D1 - Oct 13': ['Time', 'Workshop Room 1', 'Workshop Room 2', 'General'],
            'D2 - Oct 14': ['Time', 'Workshop Room 1', 'Workshop Room 2', 'General'],
            'D3 - Oct 15': ['Time', 'Socratic Bitdevs', 'Main Stage', 'General'],
            'D4 - Oct 16': ['Time', 'Socratic Bitdevs', 'Main Stage', 'General']
        };
        const ACCEPTED_LABELS = new Set(['accepted', 'confirmed']);
        const norm = (s) => String(s || '').trim().toLowerCase();

        /* === Tiny color util based on labels === */
        function hashColor(str) { let h = 5381; for (let i = 0; i < str.length; i++)h = ((h << 5) + h) + str.charCodeAt(i); const hex = (h >>> 0).toString(16).padStart(8, '0'); return `#${hex.slice(-6)}`; }
        function hexToRgb(hex) { const v = hex.replace('#', ''); return { r: parseInt(v.slice(0, 2), 16), g: parseInt(v.slice(2, 4), 16), b: parseInt(v.slice(4, 6), 16) }; }
        function colorFromLabels(ev) { const names = (ev.labels || []).map(l => l?.name || '').filter(Boolean).map(s => s.trim()).filter(n => !ACCEPTED_LABELS.has(n.toLowerCase())).sort(); const key = names.join('|') || 'default'; const hex = hashColor(key); const { r, g, b } = hexToRgb(hex); return { bg: `rgba(${r}, ${g}, ${b}, 0.18)`, br: `rgba(${r}, ${g}, ${b}, 0.45)` }; }

        /* === Parse ONLY startTime / endTime === */
        function parseTime(t) {
            if (!t) return null;
            const s = String(t).trim().toUpperCase().replace(/\s+/g, ''); // allow "11:30AM" & "11:30 AM"
            const m = s.match(/^(\d{1,2})(?::(\d{2}))?(AM|PM)$/);
            if (!m) return null;
            let h = parseInt(m[1], 10); const min = m[2] ? parseInt(m[2], 10) : 0; const ap = m[3];
            if (ap === 'PM' && h < 12) h += 12; if (ap === 'AM' && h === 12) h = 0;
            return { minutes: h * 60 + min };
        }
        function fmtTime(mins) { const h24 = Math.floor(mins / 60), m = mins % 60, ap = h24 >= 12 ? 'PM' : 'AM'; let h = h24 % 12; if (h === 0) h = 12; return `${h}:${String(m).padStart(2, '0')} ${ap}`; }

        /* === Days expansion (generic) === */
        function dayKeyFromNum(n) {
            if (n === 0) return 'D0 - Oct 12';
            if (n === 1) return 'D1 - Oct 13';
            if (n === 2) return 'D2 - Oct 14';
            if (n === 3) return 'D3 - Oct 15';
            if (n === 4) return 'D4 - Oct 16';
            return null;
        }
        function expandDays(dayStr) {
            const s = norm(dayStr);
            if (!s) return [];
            if (s.includes('all')) return ['D1 - Oct 13', 'D2 - Oct 14', 'D3 - Oct 15', 'D4 - Oct 16']; // generic choice
            const nums = Array.from(s.matchAll(/day\s*([0-4])/g)).map(m => parseInt(m[1], 10));
            const keys = [...new Set(nums.map(dayKeyFromNum).filter(Boolean))];
            return keys.length ? keys : [];
        }

        /* === Simple villageâ†’column mapping (generic synonyms) === */
        function mapToColumn(dayKey, village) {
            const cols = DAY_COLUMNS[dayKey] || ['Time', 'General'];
            const colNames = cols.slice(1); // skip Time
            const v = norm(village);
            // direct matches by name
            for (const name of colNames) {
                if (v.includes(norm(name))) return name;
            }
            // friendly synonyms
            if ((v.includes('bitdev') || v.includes('socratic')) && colNames.includes('Socratic Bitdevs')) return 'Socratic Bitdevs';
            if ((v.includes('mainstage') || v.includes('main stage')) && colNames.includes('Main Stage')) return 'Main Stage';
            if ((v.includes('room1') || v.includes('workshop room 1') || v.includes('wr1')) && colNames.includes('Workshop Room 1')) return 'Workshop Room 1';
            if ((v.includes('room2') || v.includes('workshop room 2') || v.includes('wr2')) && colNames.includes('Workshop Room 2')) return 'Workshop Room 2';
            return colNames.includes('General') ? 'General' : colNames[0] || 'General';
        }

        /* === Type filter === */
        function matchesType(ev, typeVal) {
            if (typeVal === 'all') return true;
            const names = (ev.labels || []).map(l => (l?.name || '').toLowerCase());
            return names.includes(typeVal.toLowerCase());
        }

        async function load() {
            const res = await fetch('data/schedule.json', { cache: 'no-store' });
            const all = await res.json();

            const daySel = document.getElementById('dayFilter');
            const typeSel = document.getElementById('typeFilter');
            const daysEl = document.getElementById('days');

            function render() {
                const dayVal = daySel.value;
                const typeVal = typeSel.value;

                // Expand each item into one or more day buckets (no special casing)
                const perDay = new Map();
                for (const ev of all) {
                    const dayKeys = expandDays(ev.day);
                    if (!dayKeys.length) continue;
                    // times must parse
                    const s = parseTime(ev.startTime), e = parseTime(ev.endTime);
                    if (!s || !e || e.minutes <= s.minutes) continue;
                    if (!matchesType(ev, typeVal)) continue;

                    for (const dk of dayKeys) {
                        if (dayVal !== 'all' && dk !== dayVal) continue;
                        if (!perDay.has(dk)) perDay.set(dk, []);
                        perDay.get(dk).push(ev);
                    }
                }

                daysEl.innerHTML = '';

                for (const dayKey of DAY_ORDER) {
                    const items = perDay.get(dayKey) || [];
                    if (!items.length) continue;

                    const cols = DAY_COLUMNS[dayKey];
                    const colNames = cols.slice(1);

                    // Build time ticks
                    const tickSet = new Set();
                    let minT = Infinity, maxT = -Infinity;
                    for (const ev of items) {
                        const s = parseTime(ev.startTime).minutes, e = parseTime(ev.endTime).minutes;
                        tickSet.add(s); tickSet.add(e);
                        if (s < minT) minT = s; if (e > maxT) maxT = e;
                    }
                    const ticks = Array.from(tickSet).sort((a, b) => a - b);
                    if (ticks.length < 2) continue;
                    const idxOf = (m) => ticks.indexOf(m);

                    // bucket items by column
                    const byCol = new Map(colNames.map(n => [n, []]));
                    for (const ev of items) {
                        const col = mapToColumn(dayKey, ev.village);
                        if (!byCol.has(col)) byCol.set(col, []);
                        byCol.get(col).push(ev);
                    }

                    // groups per column by identical span
                    const groupsByCol = new Map();
                    for (const [col, arr] of byCol.entries()) {
                        const gmap = new Map();
                        for (const ev of arr) {
                            const s = idxOf(parseTime(ev.startTime).minutes);
                            const e = idxOf(parseTime(ev.endTime).minutes);
                            if (s === -1 || e === -1 || e <= s) continue;
                            const key = `${s}-${e}`;
                            if (!gmap.has(key)) gmap.set(key, { si: s, ei: e, items: [] });
                            gmap.get(key).items.push(ev);
                        }
                        const groups = Array.from(gmap.values()).sort((a, b) => a.si - b.si || a.ei - b.ei);
                        groupsByCol.set(col, groups);
                    }

                    // Build table
                    const card = document.createElement('div');
                    card.className = 'day-card';
                    card.innerHTML = `<div class="day-title">${DAY_LABELS[dayKey] || dayKey}</div>`;

                    const table = document.createElement('table');
                    const thead = document.createElement('thead');
                    const trh = document.createElement('tr');
                    for (const head of cols) { const th = document.createElement('th'); th.textContent = head; trh.appendChild(th); }
                    thead.appendChild(trh); table.appendChild(thead);
                    const tbody = document.createElement('tbody');

                    // occupancy grid: for each column, mark rows covered by a rowspan
                    const occ = new Map(colNames.map(n => [n, Array(ticks.length - 1).fill(false)]));

                    for (let r = 0; r < ticks.length - 1; r++) {
                        const tr = document.createElement('tr');

                        const th = document.createElement('th');
                        th.className = 'timecell';
                        const compact = matchMedia('(max-width: 640px)').matches;
                        th.innerHTML = compact ? `${fmtTime(ticks[r])}<br>${fmtTime(ticks[r + 1])}` : `${fmtTime(ticks[r])} - ${fmtTime(ticks[r + 1])}`;
                        tr.appendChild(th);

                        for (const col of colNames) {
                            if (occ.get(col)[r]) continue; // covered by rowspan from earlier row

                            const td = document.createElement('td');
                            const stack = document.createElement('div');
                            stack.className = 'stack';

                            // group that starts exactly at this row?
                            const group = (groupsByCol.get(col) || []).find(g => g.si === r && !g.used);
                            if (group) {
                                const span = group.ei - group.si;
                                for (let k = r; k < group.ei; k++) occ.get(col)[k] = true;

                                const single = group.items.length === 1;
                                for (const ev of group.items) {
                                    const { bg, br } = colorFromLabels(ev);
                                    const box = document.createElement('div');
                                    box.className = 'slot' + (single ? ' single' : '');
                                    box.style.background = bg;
                                    box.style.borderColor = br;
                                    box.style.borderStyle = 'solid';

                                    const h = document.createElement('h4');
                                    const a = document.createElement('a');
                                    a.href = ev.url || '#'; a.target = '_blank'; a.rel = 'noopener noreferrer';
                                    a.textContent = ev.title || 'Untitled';
                                    h.appendChild(a); box.appendChild(h);

                                    const meta = document.createElement('div');
                                    meta.className = 'meta';
                                    const assignees = (ev.assignees || '').split(',').map(s => s.trim()).filter(Boolean)
                                        .map(u => `<a href="https://github.com/${u}" target="_blank" rel="noopener noreferrer">@${u}</a>`).join(' ');
                                    meta.innerHTML = assignees; box.appendChild(meta);

                                    const clean = (ev.labels || []).filter(l => l?.name && !ACCEPTED_LABELS.has(l.name.toLowerCase()));
                                    if (clean.length) {
                                        const badges = document.createElement('div'); badges.className = 'badges';
                                        clean.forEach(l => { const b = document.createElement('span'); b.className = 'badge'; b.textContent = l.name; badges.appendChild(b); });
                                        box.appendChild(badges);
                                    }

                                    stack.appendChild(box);
                                }

                                td.setAttribute('rowspan', String(span));
                                group.used = true;
                            }

                            td.appendChild(stack);
                            tr.appendChild(td);
                        }

                        tbody.appendChild(tr);
                    }

                    table.appendChild(tbody);
                    card.appendChild(table);
                    document.getElementById('days').appendChild(card);
                }

                if (!daysEl.children.length) {
                    daysEl.innerHTML = '<div class="day-card"><div class="day-title">No matching sessions</div></div>';
                }
            }

            document.getElementById('dayFilter').addEventListener('change', render);
            document.getElementById('typeFilter').addEventListener('change', render);
            render();
        }

        load().catch(err => {
            document.getElementById('days').innerHTML = `<div class="day-card"><div class="day-title">Error loading schedule</div><div style="padding:12px;color:#f99;">${String(err)}</div></div>`;
            console.error(err);
        });
    </script>
</body>

</html>
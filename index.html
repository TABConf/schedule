<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>TABConf Schedule</title>
    <style>
        :root {
            --bg: #0f1115;
            --card: #171a21;
            --muted: #aab2c0;
            --text: #e6e9ef;
            --accent: #4da3ff;
            --border: #2a2f3a;
        }

        html,
        body {
            background: var(--bg);
            color: var(--text);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            margin: 0;
            padding: 0;
        }

        .wrap {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px 16px 48px;
        }

        header {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }

        h1 {
            font-size: 24px;
            margin: 0 0 4px 0;
        }

        .filters {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
            background: var(--card);
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: 12px;
        }

        .filters label {
            font-size: 14px;
            color: var(--muted);
        }

        select {
            background: #0d0f14;
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 8px 10px;
            font-size: 14px;
        }

        .legend {
            font-size: 12px;
            color: var(--muted);
            margin-left: auto;
        }

        .day-card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            margin-top: 18px;
        }

        .day-title {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            background: #11141a;
        }

        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            table-layout: fixed;
        }

        thead th {
            position: sticky;
            top: 0;
            background: #11141a;
            z-index: 1;
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            font-size: 13px;
            padding: 10px;
        }

        tbody td,
        tbody th {
            border-bottom: 1px solid var(--border);
            vertical-align: top;
            padding: 8px;
            font-size: 13px;
            word-wrap: break-word;
        }

        tbody th.timecell {
            color: var(--muted);
            width: 90px;
            font-weight: 500;
            white-space: nowrap;
        }

        .slot {
            border: 1px solid transparent;
            border-radius: 10px;
            padding: 8px;
            backdrop-filter: saturate(120%);
        }

        .slot h4 {
            margin: 0 0 6px 0;
            font-size: 14px;
            line-height: 1.25;
        }

        .slot .meta {
            font-size: 12px;
            color: var(--muted);
        }

        .badges {
            display: inline-flex;
            gap: 6px;
            flex-wrap: wrap;
            margin: 6px 0 0 0;
        }

        .badge {
            border: 1px solid var(--border);
            background: rgba(255, 255, 255, 0.05);
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 999px;
        }

        a {
            color: var(--accent);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        /* Mobile responsiveness */
        @media (max-width: 800px) {
            thead {
                display: none;
            }

            table,
            tbody,
            tr,
            td,
            th {
                display: block;
                width: 100%;
            }

            tbody th.timecell {
                width: auto;
            }

            tbody tr {
                border-bottom: 1px solid var(--border);
                padding: 8px 0;
            }

            tbody td {
                padding: 6px 0;
            }

            .col-label {
                display: block;
                font-size: 11px;
                color: var(--muted);
                margin-bottom: 4px;
            }
        }
    </style>
</head>

<body>
    <div class="wrap">
        <header>
            <div>
                <h1>TABConf Schedule</h1>
                <div class="filters">
                    <label for="dayFilter">Day:</label>
                    <select id="dayFilter">
                        <option value="all">All days</option>
                        <option value="D1 - Oct 13">D1 - Oct 13</option>
                        <option value="D2 - Oct 14">D2 - Oct 14</option>
                        <option value="D3 - Oct 15">D3 - Oct 15</option>
                        <option value="D4 - Oct 16">D4 - Oct 16</option>
                    </select>

                    <label for="typeFilter">Type:</label>
                    <select id="typeFilter">
                        <option value="all">All types</option>
                        <option>Workshop</option>
                        <option>Talk</option>
                        <option>Panel</option>
                        <option>Debate</option>
                        <option>Unrecorded</option>
                        <option>Beginner</option>
                        <option>Advanced</option>
                        <option>Builder Days</option>
                        <option>Events</option>
                    </select>

                    <div class="legend">Select filters to refine. Days without matches are hidden.</div>
                </div>
            </div>
        </header>

        <div id="days"></div>
    </div>

    <script>
        const DAY_LABELS = {
            'D1 - Oct 13': 'Day 1 - October 13',
            'D2 - Oct 14': 'Day 2 - October 14',
            'D3 - Oct 15': 'Day 3 - October 15',
            'D4 - Oct 16': 'Day 4 - October 16'
        };

        const DAY_COLUMNS = {
            // [time, col2, col3, col4]
            'D1 - Oct 13': ['Time', 'Workshop Room 1', 'Workshop Room 2', 'General'],
            'D2 - Oct 14': ['Time', 'Workshop Room 1', 'Workshop Room 2', 'General'],
            'D3 - Oct 15': ['Time', 'Socratic Bitdevs', 'Main Stage', 'General'],
            'D4 - Oct 16': ['Time', 'Socratic Bitdevs', 'Main Stage', 'General']
        };

        const ACCEPTED_LABELS = new Set(['accepted', 'confirmed']);

        // Deterministic color from sorted labels string
        function hashColor(str) {
            // djb2
            let h = 5381;
            for (let i = 0; i < str.length; i++) h = ((h << 5) + h) + str.charCodeAt(i);
            const hex = (h >>> 0).toString(16).padStart(8, '0');
            const rgb = hex.slice(-6); // 24-bit
            return `#${rgb}`;
        }

        function hexToRgb(hex) {
            const v = hex.replace('#', '');
            const r = parseInt(v.slice(0, 2), 16);
            const g = parseInt(v.slice(2, 4), 16);
            const b = parseInt(v.slice(4, 6), 16);
            return { r, g, b };
        }

        function parseTime(t) {
            if (!t) return null;
            // Accept formats like "7", "7am", "7:00", "7:00 AM", "07:30", "19:00"
            const s = String(t).trim().toUpperCase();
            const m = s.match(/^(\d{1,2})(?::(\d{2}))?\s*(AM|PM)?$/);
            if (!m) return null;
            let hour = parseInt(m[1], 10);
            let min = m[2] ? parseInt(m[2], 10) : 0;
            const ap = m[3] || null;
            if (ap === 'PM' && hour < 12) hour += 12;
            if (ap === 'AM' && hour === 12) hour = 0;
            return { h: hour, m: min, minutes: hour * 60 + min };
        }

        function fmtTime(mins) {
            const h24 = Math.floor(mins / 60);
            const m = mins % 60;
            const ampm = h24 >= 12 ? 'PM' : 'AM';
            let h = h24 % 12; if (h === 0) h = 12;
            return `${h}:${String(m).padStart(2, '0')} ${ampm}`;
        }

        function normalizeDayKey(dayValue) {
            if (!dayValue) return null;
            const s = String(dayValue).toLowerCase();
            if (s.startsWith('d1')) return 'D1 - Oct 13';
            if (s.startsWith('d2')) return 'D2 - Oct 14';
            if (s.startsWith('d3')) return 'D3 - Oct 15';
            if (s.startsWith('d4')) return 'D4 - Oct 16';
            // Attempt matching full titles
            for (const [k, v] of Object.entries(DAY_LABELS)) {
                if (s.includes(v.toLowerCase().split(' - ')[0])) return k;
            }
            return null;
        }

        function eventMatchesType(ev, typeVal) {
            if (typeVal === 'all') return true;
            const names = (ev.labels || []).map(l => (l.name || '').toLowerCase());
            return names.includes(typeVal.toLowerCase());
        }

        function computeColorFromLabels(ev) {
            const names = (ev.labels || [])
                .map(l => l.name)
                .filter(Boolean)
                .map(x => x.trim())
                .filter(x => !ACCEPTED_LABELS.has(x.toLowerCase()))
                .sort((a, b) => a.localeCompare(b));
            const key = names.join('|');
            const hex = hashColor(key.length ? key : 'default');
            const { r, g, b } = hexToRgb(hex);
            return { hex, rgbaBg: `rgba(${r}, ${g}, ${b}, 0.18)`, border: `rgba(${r}, ${g}, ${b}, 0.45)` };
        }

        async function load() {
            const res = await fetch('data/schedule.json', { cache: 'no-store' });
            const all = await res.json();

            const daySel = document.getElementById('dayFilter');
            const typeSel = document.getElementById('typeFilter');
            const daysEl = document.getElementById('days');

            function render() {
                const dayVal = daySel.value;
                const typeVal = typeSel.value;

                // Filter and bucket by normalized day key
                const buckets = new Map();
                for (const item of all) {
                    const dayKey = normalizeDayKey(item.day) || item.day || '';
                    if (!DAY_COLUMNS[dayKey]) continue;
                    if (dayVal !== 'all' && dayKey !== dayVal) continue;
                    if (!eventMatchesType(item, typeVal)) continue;
                    if (!buckets.has(dayKey)) buckets.set(dayKey, []);
                    buckets.get(dayKey).push(item);
                }

                // Clear
                daysEl.innerHTML = '';

                // Sort days in the known order
                const order = Object.keys(DAY_COLUMNS);
                for (const dayKey of order) {
                    const list = buckets.get(dayKey) || [];
                    if (list.length === 0) continue; // hide day with no matches

                    // Compute time grid for this day from Start Time and End Time
                    const times = new Set();
                    let minStart = Infinity, maxEnd = -Infinity;
                    for (const ev of list) {
                        const start = parseTime(ev.startTime || ev.time?.split('-')[0]);
                        const end = parseTime(ev.endTime || ev.time?.split('-')[1]);
                        if (!start || !end) continue;
                        times.add(start.minutes);
                        times.add(end.minutes);
                        minStart = Math.min(minStart, start.minutes);
                        maxEnd = Math.max(maxEnd, end.minutes);
                    }
                    if (!isFinite(minStart) || !isFinite(maxEnd)) continue;

                    const sortedTicks = Array.from(times).sort((a, b) => a - b);

                    // Build occupancy grid to manage rowSpans per column
                    const cols = DAY_COLUMNS[dayKey];
                    const colNames = cols.slice(1); // exclude Time header

                    // Bucket events per column by village name matching column, else General
                    const byCol = new Map(colNames.map(n => [n, []]));
                    for (const ev of list) {
                        const target = colNames.find(n => (ev.village || '').toLowerCase() === n.toLowerCase()) || 'General';
                        if (!byCol.has(target)) byCol.set(target, []);
                        byCol.get(target).push(ev);
                    }

                    // For each column, map events to startIndex/endIndex in sortedTicks
                    function toIdx(mins) { return sortedTicks.findIndex(x => x === mins); }

                    const placed = new Map();
                    for (const [col, arr] of byCol.entries()) {
                        const mapped = [];
                        for (const ev of arr) {
                            const s = parseTime(ev.startTime || ev.time?.split('-')[0]);
                            const e = parseTime(ev.endTime || ev.time?.split('-')[1]);
                            if (!s || !e) continue;
                            const si = toIdx(s.minutes);
                            const ei = toIdx(e.minutes);
                            if (si === -1 || ei === -1 || ei <= si) continue;
                            mapped.push({ ev, si, ei });
                        }
                        // sort by start then end
                        mapped.sort((a, b) => a.si - b.si || a.ei - b.ei);
                        placed.set(col, mapped);
                    }

                    // Build table DOM
                    const card = document.createElement('div');
                    card.className = 'day-card';
                    card.innerHTML = `<div class="day-title">${DAY_LABELS[dayKey] || dayKey}</div>`;

                    const table = document.createElement('table');
                    const thead = document.createElement('thead');
                    const trh = document.createElement('tr');
                    for (const head of cols) {
                        const th = document.createElement('th');
                        th.textContent = head;
                        trh.appendChild(th);
                    }
                    thead.appendChild(trh);
                    table.appendChild(thead);

                    const tbody = document.createElement('tbody');

                    // Track occupied rows per column to place rowSpans
                    const occupancy = new Map(colNames.map(n => [n, Array(sortedTicks.length - 1).fill(false)]));

                    for (let r = 0; r < sortedTicks.length - 1; r++) {
                        const row = document.createElement('tr');

                        // Time label for this interval
                        const tcell = document.createElement('th');
                        tcell.className = 'timecell';
                        tcell.textContent = `${fmtTime(sortedTicks[r])} - ${fmtTime(sortedTicks[r + 1])}`;
                        row.appendChild(tcell);

                        for (const col of colNames) {
                            // If an existing spanning cell covers this row, skip creating a td
                            if (occupancy.get(col)[r]) continue;

                            // Find an event that starts at r in this column
                            const evSpan = (placed.get(col) || []).find(x => x.si === r);
                            const td = document.createElement('td');

                            if (evSpan) {
                                const span = evSpan.ei - evSpan.si;
                                // Mark occupied rows for this column
                                for (let k = r; k < evSpan.ei; k++) occupancy.get(col)[k] = true;

                                const { hex, rgbaBg, border } = computeColorFromLabels(evSpan.ev);
                                const box = document.createElement('div');
                                box.className = 'slot';
                                box.style.background = rgbaBg;
                                box.style.borderColor = border;

                                const title = document.createElement('h4');
                                const tlink = document.createElement('a');
                                tlink.href = evSpan.ev.url || '#';
                                tlink.target = '_blank';
                                tlink.rel = 'noopener noreferrer';
                                tlink.textContent = evSpan.ev.title || 'Untitled';
                                title.appendChild(tlink);
                                box.appendChild(title);

                                const meta = document.createElement('div');
                                meta.className = 'meta';
                                const assignees = (evSpan.ev.assignees || '')
                                    .split(',')
                                    .map(s => s.trim())
                                    .filter(Boolean)
                                    .map(u => `<a href="https://github.com/${u}" target="_blank" rel="noopener noreferrer">@${u}</a>`)
                                    .join(' ');
                                meta.innerHTML = `${assignees}`;
                                box.appendChild(meta);

                                // Badges for labels minus Accepted/confirmed
                                const cleanLabels = (evSpan.ev.labels || [])
                                    .filter(l => l && l.name && !ACCEPTED_LABELS.has(l.name.toLowerCase()));
                                if (cleanLabels.length) {
                                    const badges = document.createElement('div');
                                    badges.className = 'badges';
                                    cleanLabels.forEach(l => {
                                        const b = document.createElement('span');
                                        b.className = 'badge';
                                        b.textContent = l.name;
                                        badges.appendChild(b);
                                    });
                                    box.appendChild(badges);
                                }

                                td.appendChild(box);
                                td.setAttribute('rowspan', String(span));
                                row.appendChild(td);
                            } else {
                                // empty cell
                                row.appendChild(td);
                            }
                        }

                        tbody.appendChild(row);
                    }

                    table.appendChild(tbody);
                    card.appendChild(table);
                    daysEl.appendChild(card);
                }

                if (!daysEl.children.length) {
                    daysEl.innerHTML = '<div class="day-card"><div class="day-title">No matching sessions</div></div>';
                }
            }

            daySel.addEventListener('change', render);
            typeSel.addEventListener('change', render);
            render();
        }

        load().catch(err => {
            document.getElementById('days').innerHTML = `<div class="day-card"><div class="day-title">Error loading schedule</div><div style="padding:12px;color:#f99;">${String(err)}</div></div>`;
            console.error(err);
        });
    </script>
</body>

</html>
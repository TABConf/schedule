<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes" />
    <title>TABConf Schedule</title>
    <style>
        :root {
            --bg: #0f1115;
            --card: #171a21;
            --muted: #aab2c0;
            --text: #e6e9ef;
            --accent: #4da3ff;
            --border: #2a2f3a;
        }

        html,
        body {
            background: var(--bg);
            color: var(--text);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            margin: 0;
            padding: 0;
        }

        .wrap {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px 16px 48px;
        }

        header {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }

        h1 {
            font-size: 24px;
            margin: 0 0 4px 0;
        }

        .filters {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
            background: var(--card);
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: 12px;
        }

        .filters label {
            font-size: 14px;
            color: var(--muted);
        }

        select {
            background: #0d0f14;
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 8px 10px;
            font-size: 14px;
        }

        .legend {
            font-size: 12px;
            color: var(--muted);
            margin-left: auto;
        }

        .day-card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            margin-top: 18px;
        }

        .day-title {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            background: #11141a;
        }

        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            table-layout: fixed;
        }

        thead th {
            position: sticky;
            top: 0;
            background: #11141a;
            z-index: 1;
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            font-size: 13px;
            padding: 10px;
        }

        tbody td,
        tbody th {
            border-bottom: 1px solid var(--border);
            vertical-align: top;
            padding: 8px;
            font-size: 13px;
            word-wrap: break-word;
        }

        tbody th.timecell {
            color: var(--muted);
            width: 90px;
            font-weight: 500;
            white-space: nowrap;
        }

        /* TDs must be normal-positioned so content dictates row height */
        tbody td {
            position: static;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* Cards */
        .slot {
            border: 1px solid transparent;
            border-radius: 10px;
            padding: 8px;
            backdrop-filter: saturate(120%);
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* contain long content */
        }

        /* Mark special “General” little cards */
        .slot.special {
            font-size: 12px;
            padding: 6px 8px;
        }

        .slot h4 {
            margin: 0 0 6px 0;
            font-size: 14px;
            line-height: 1.25;
        }

        .slot .meta {
            font-size: 12px;
            color: var(--muted);
        }

        .badges {
            display: inline-flex;
            gap: 6px;
            flex-wrap: wrap;
            margin: 6px 0 0 0;
        }

        .badge {
            border: 1px solid var(--border);
            background: rgba(255, 255, 255, 0.05);
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 999px;
        }

        a {
            color: var(--accent);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        @media (max-width: 640px) {
            tbody th.timecell {
                width: 68px;
                white-space: normal;
                line-height: 1.2;
                font-size: 12px;
                text-align: right;
            }
        }
    </style>
</head>

<body>
    <div class="wrap">
        <header>
            <div>
                <h1>TABConf Schedule</h1>
                <div class="filters">
                    <label for="dayFilter">Day:</label>
                    <select id="dayFilter">
                        <option value="all">All days</option>
                        <option value="D0 - Oct 12">D0 - Oct 12</option>
                        <option value="D1 - Oct 13">D1 - Oct 13</option>
                        <option value="D2 - Oct 14">D2 - Oct 14</option>
                        <option value="D3 - Oct 15">D3 - Oct 15</option>
                        <option value="D4 - Oct 16">D4 - Oct 16</option>
                    </select>

                    <label for="typeFilter">Type:</label>
                    <select id="typeFilter">
                        <option value="all">All types</option>
                        <option>Workshop</option>
                        <option>Talk</option>
                        <option>Panel</option>
                        <option>Debate</option>
                        <option>Unrecorded</option>
                        <option>Beginner</option>
                        <option>Advanced</option>
                        <option>Builder Days Project</option>
                        <option>Events</option>
                    </select>

                    <div class="legend">
                        Select filters to refine. Days without matches are hidden.
                        <a href="https://github.com/orgs/TABConf/projects/9" target="_blank"
                            rel="noopener noreferrer">See the project schedule on Github</a>.
                    </div>
                </div>
            </div>
        </header>

        <div id="days"></div>
    </div>

    <script>
        const DAY_LABELS = {
            'D0 - Oct 12': 'Day 0 - October 12',
            'D1 - Oct 13': 'Day 1 - October 13',
            'D2 - Oct 14': 'Day 2 - October 14',
            'D3 - Oct 15': 'Day 3 - October 15',
            'D4 - Oct 16': 'Day 4 - October 16'
        };

        const DAY_COLUMNS = {
            'D0 - Oct 12': ['Time', 'General'], // Day 0 = single column
            'D1 - Oct 13': ['Time', 'Workshop Room 1', 'Workshop Room 2', 'General'],
            'D2 - Oct 14': ['Time', 'Workshop Room 1', 'Workshop Room 2', 'General'],
            'D3 - Oct 15': ['Time', 'Socratic Bitdevs', 'Main Stage', 'General'],
            'D4 - Oct 16': ['Time', 'Socratic Bitdevs', 'Main Stage', 'General']
        };

        const DAY_KEYS_IN_ORDER = ['D0 - Oct 12', 'D1 - Oct 13', 'D2 - Oct 14', 'D3 - Oct 15', 'D4 - Oct 16'];
        const ACCEPTED_LABELS = new Set(['accepted', 'confirmed']);

        const norm = (s) => String(s || '').trim().toLowerCase();

        function hashColor(str) {
            let h = 5381;
            for (let i = 0; i < str.length; i++) h = ((h << 5) + h) + str.charCodeAt(i);
            const hex = (h >>> 0).toString(16).padStart(8, '0');
            return `#${hex.slice(-6)}`;
        }
        function hexToRgb(hex) {
            const v = hex.replace('#', '');
            return { r: parseInt(v.slice(0, 2), 16), g: parseInt(v.slice(2, 4), 16), b: parseInt(v.slice(4, 6), 16) };
        }
        function computeColorFromLabels(ev) {
            const names = (ev.labels || [])
                .map(l => l && l.name ? l.name : '')
                .filter(Boolean)
                .map(x => x.trim())
                .filter(x => !ACCEPTED_LABELS.has(x.toLowerCase()))
                .sort((a, b) => a.localeCompare(b));
            const key = names.join('|') || 'default';
            const hex = hashColor(key);
            const { r, g, b } = hexToRgb(hex);
            return { rgbaBg: `rgba(${r}, ${g}, ${b}, 0.18)`, border: `rgba(${r}, ${g}, ${b}, 0.45)` };
        }

        function parseTime(t) {
            if (!t) return null;
            const s = String(t).trim().toUpperCase();
            if (s === 'ALL DAY') return { h: 0, m: 0, minutes: 0, allDay: true };
            const m = s.match(/^(\d{1,2})(?::(\d{2}))?\s*(AM|PM)?$/);
            if (!m) return null;
            let hour = parseInt(m[1], 10);
            let min = m[2] ? parseInt(m[2], 10) : 0;
            const ap = m[3] || null;
            if (ap === 'PM' && hour < 12) hour += 12;
            if (ap === 'AM' && hour === 12) hour = 0;
            return { h: hour, m: min, minutes: hour * 60 + min };
        }
        function fmtTime(mins) {
            const h24 = Math.floor(mins / 60);
            const m = mins % 60;
            const ampm = h24 >= 12 ? 'PM' : 'AM';
            let h = h24 % 12; if (h === 0) h = 12;
            return `${h}:${String(m).padStart(2, '0')} ${ampm}`;
        }

        function normalizeSingleDayKey(dayValue) {
            const s = norm(dayValue);
            if (s.startsWith('day 0')) return 'D0 - Oct 12';
            if (s.startsWith('day 1')) return 'D1 - Oct 13';
            if (s.startsWith('day 2')) return 'D2 - Oct 14';
            if (s.startsWith('day 3')) return 'D3 - Oct 15';
            if (s.startsWith('day 4')) return 'D4 - Oct 16';
            return null;
        }

        // Expand items to days based on rules:
        // - "Day X" -> that day
        // - "Day X & Y" -> both days
        // - "All Days" -> D1..D4 (exclude D0)
        function expandItemToDays(item) {
            const s = norm(item.day);

            // All Days -> Day 1..4 only
            if (s === 'all days' || s === 'alldays' || s === 'all') {
                return ['D1 - Oct 13', 'D2 - Oct 14', 'D3 - Oct 15', 'D4 - Oct 16'];
            }

            // Day X & Y or "Day X and Y"
            const multi = s.match(/^day\s*([0-4])\s*(?:&|and)\s*([0-4])$/);
            if (multi) {
                const a = Math.min(parseInt(multi[1], 10), parseInt(multi[2], 10));
                const b = Math.max(parseInt(multi[1], 10), parseInt(multi[2], 10));
                return [normalizeSingleDayKey(`Day ${a}`), normalizeSingleDayKey(`Day ${b}`)].filter(Boolean);
            }

            // Plain single day
            const single = normalizeSingleDayKey(item.day);
            return single ? [single] : [];
        }

        function isMultiOrAllDayItem(item) {
            const days = expandItemToDays(item);
            if (days.length > 1) return true; // multi-day like "Day 1 & 2"
            const s = norm(item.day);
            if (s === 'all days' || s === 'alldays' || s === 'all') return true; // "All Days"
            return false;
        }

        function eventMatchesType(ev, typeVal) {
            if (typeVal === 'all') return true;
            const names = (ev.labels || []).map(l => (l.name || '').toLowerCase());
            return names.includes(typeVal.toLowerCase());
        }

        function mapToValidColumn(dayKey, village, colNames) {
            // Day 0 is a single General column
            if (dayKey === 'D0 - Oct 12') return 'General';

            const v = norm(village);
            let out;
            if (dayKey === 'D3 - Oct 15' || dayKey === 'D4 - Oct 16') {
                if (v.includes('main stage')) out = 'Main Stage';
                else if (v.includes('bitdevs') || v.includes('socratic')) out = 'Socratic Bitdevs';
                else out = 'General';
            } else {
                if (v.includes('workshop room 1')) out = 'Workshop Room 1';
                else if (v.includes('workshop room 2')) out = 'Workshop Room 2';
                else out = 'General';
            }
            if (!colNames.includes(out)) out = colNames.includes('General') ? 'General' : colNames[0];
            return out;
        }

        async function load() {
            const res = await fetch('data/schedule.json', { cache: 'no-store' });
            const all = await res.json();

            const daySel = document.getElementById('dayFilter');
            const typeSel = document.getElementById('typeFilter');
            const daysEl = document.getElementById('days');

            function render() {
                const dayVal = daySel.value;
                const typeVal = typeSel.value;

                // Build per-day lists respecting expansion rules
                const byDay = new Map(); // dayKey -> array of items for that day
                for (const item of all) {
                    const dayKeys = expandItemToDays(item);
                    // If no expansion resolved (empty or malformed), skip
                    if (!dayKeys.length) continue;
                    for (const dk of dayKeys) {
                        if (!DAY_COLUMNS[dk]) continue;
                        if (dayVal !== 'all' && dk !== dayVal) continue;
                        if (!eventMatchesType(item, typeVal)) continue;
                        if (!byDay.has(dk)) byDay.set(dk, []);
                        byDay.get(dk).push(item);
                    }
                }

                daysEl.innerHTML = '';

                for (const dayKey of DAY_KEYS_IN_ORDER) {
                    const list = byDay.get(dayKey) || [];
                    if (!list.length) continue;

                    const cols = DAY_COLUMNS[dayKey];
                    const colNames = cols.slice(1); // headers except Time

                    // Partition into:
                    //   - regularItems: single-day items (go to mapped column)
                    //   - specialGeneral: multi-day or All Days -> always GENERAL for this day
                    const regularItems = [];
                    const specialGeneral = [];
                    for (const ev of list) {
                        if (isMultiOrAllDayItem(ev)) {
                            specialGeneral.push(ev);
                        } else {
                            regularItems.push(ev);
                        }
                    }

                    // Build time ticks: from all regular items (start/end) + the specialGeneral START times
                    const times = new Set();
                    let minStart = Infinity, maxEnd = -Infinity;

                    function addBoundsFrom(ev) {
                        const s = parseTime(ev.startTime || ev.time?.split('-')[0]);
                        const e = parseTime(ev.endTime || ev.time?.split('-')[1]);
                        if (s && typeof s.minutes === 'number') {
                            times.add(s.minutes);
                            minStart = Math.min(minStart, s.minutes);
                        }
                        if (e && typeof e.minutes === 'number') {
                            times.add(e.minutes);
                            maxEnd = Math.max(maxEnd, e.minutes);
                        }
                    }

                    for (const ev of regularItems) addBoundsFrom(ev);
                    for (const ev of specialGeneral) {
                        const s = parseTime(ev.startTime || ev.time?.split('-')[0] || '10:00 AM'); // fallback start so they show
                        if (s) {
                            times.add(s.minutes);
                            minStart = Math.min(minStart, s.minutes);
                        }
                        // special cards don't stretch: no need to push end bound
                    }

                    if (!isFinite(minStart) || !isFinite(maxEnd)) {
                        // If a day has only specialGeneral items with times but no ends, ensure at least one trailing tick
                        if (isFinite(minStart)) {
                            maxEnd = minStart + 60; // one hour window as a fallback
                            times.add(maxEnd);
                        } else {
                            continue; // nothing renderable
                        }
                    }

                    const sortedTicks = Array.from(times).sort((a, b) => a - b);

                    // Bucket regular items into columns
                    const byCol = new Map(colNames.map(n => [n, []]));
                    for (const ev of regularItems) {
                        const target = mapToValidColumn(dayKey, ev.village, colNames);
                        byCol.get(target).push(ev);
                    }

                    const toIdx = (mins) => sortedTicks.findIndex(x => x === mins);

                    // Build regular groups by identical span per column (so they can rowSpan)
                    const groupsByCol = new Map();
                    for (const [col, arr] of byCol.entries()) {
                        const gmap = new Map();
                        for (const ev of arr) {
                            const s = parseTime(ev.startTime || ev.time?.split('-')[0]);
                            const e = parseTime(ev.endTime || ev.time?.split('-')[1]);
                            if (!s || !e) continue;
                            const si = toIdx(s.minutes);
                            const ei = toIdx(e.minutes);
                            if (si === -1 || ei === -1 || ei <= si) continue;
                            const key = `${si}-${ei}`;
                            if (!gmap.has(key)) gmap.set(key, { si, ei, items: [] });
                            gmap.get(key).items.push(ev);
                        }
                        const groups = Array.from(gmap.values()).sort((a, b) => a.si - b.si || a.ei - b.ei);
                        groupsByCol.set(col, groups);
                    }

                    // Prepare special-general placement by start index,
                    // with conflict shifting to next available row if needed.
                    const generalColName = colNames.includes('General') ? 'General' : colNames[colNames.length - 1];
                    const specialAtIdx = new Map(); // startIdx -> [items]
                    for (const ev of specialGeneral) {
                        const s = parseTime(ev.startTime || ev.time?.split('-')[0] || '10:00 AM');
                        const idx = s ? toIdx(s.minutes) : 0;
                        const key = idx >= 0 ? idx : 0;
                        if (!specialAtIdx.has(key)) specialAtIdx.set(key, []);
                        specialAtIdx.get(key).push(ev);
                    }

                    // Build the DOM for this day
                    const card = document.createElement('div');
                    card.className = 'day-card';
                    card.innerHTML = `<div class="day-title">${DAY_LABELS[dayKey] || dayKey}</div>`;

                    const table = document.createElement('table');
                    const thead = document.createElement('thead');
                    const trh = document.createElement('tr');
                    for (const head of cols) {
                        const th = document.createElement('th');
                        th.textContent = head;
                        trh.appendChild(th);
                    }
                    thead.appendChild(trh);
                    table.appendChild(thead);

                    const tbody = document.createElement('tbody');

                    // Occupancy tracks which (row index) is consumed by a rowspan in each column
                    const occupancy = new Map(colNames.map(n => [n, Array(sortedTicks.length - 1).fill(false)]));

                    // Utility: for General specials, if their desired row is blocked by an existing rowspan,
                    // move them to the next free row (same day).
                    function shiftSpecialIfBlocked(idx) {
                        const occ = occupancy.get(generalColName);
                        let k = Math.max(0, idx);
                        while (k < occ.length && occ[k]) k++;
                        return Math.min(k, occ.length - 1);
                    }

                    // Iterate time rows
                    for (let r = 0; r < sortedTicks.length - 1; r++) {
                        const row = document.createElement('tr');

                        // Time cell
                        const tcell = document.createElement('th');
                        tcell.className = 'timecell';
                        const compact = matchMedia('(max-width: 640px)').matches;
                        tcell.innerHTML = compact
                            ? `${fmtTime(sortedTicks[r])}<br>${fmtTime(sortedTicks[r + 1])}`
                            : `${fmtTime(sortedTicks[r])} - ${fmtTime(sortedTicks[r + 1])}`;
                        row.appendChild(tcell);

                        // Before rendering cells, handle special-at-this-index deferrals if the row is blocked
                        if (specialAtIdx.has(r) && occupancy.get(generalColName)[r]) {
                            // Move all specials to the next available free row
                            const items = specialAtIdx.get(r);
                            specialAtIdx.delete(r);
                            const k = shiftSpecialIfBlocked(r);
                            if (!specialAtIdx.has(k)) specialAtIdx.set(k, []);
                            specialAtIdx.get(k).push(...items);
                        }

                        for (const col of colNames) {
                            // Skip if currently covered by a rowspan
                            if (occupancy.get(col)[r]) continue;

                            const td = document.createElement('td');

                            // Is there a regular group starting now?
                            const group = (groupsByCol.get(col) || []).find(g => g.si === r && !g.used);

                            // SPECIAL: insert General small cards scheduled for this row
                            if (col === generalColName && specialAtIdx.has(r)) {
                                const specials = specialAtIdx.get(r);
                                specialAtIdx.delete(r);
                                for (const ev of specials) {
                                    const { rgbaBg, border } = computeColorFromLabels(ev);
                                    const box = document.createElement('div');
                                    box.className = 'slot special';
                                    box.style.background = rgbaBg;
                                    box.style.borderColor = border;

                                    const title = document.createElement('h4');
                                    title.style.fontSize = '13px';
                                    const a = document.createElement('a');
                                    a.href = ev.url || '#';
                                    a.target = '_blank';
                                    a.rel = 'noopener noreferrer';
                                    a.textContent = ev.title || 'Untitled';
                                    title.appendChild(a);
                                    box.appendChild(title);

                                    // small meta (no stretching)
                                    const meta = document.createElement('div');
                                    meta.className = 'meta';
                                    meta.textContent = (ev.time && ev.time.toLowerCase() === 'all day')
                                        ? 'All day'
                                        : (ev.startTime ? `${ev.startTime}${ev.endTime ? ` – ${ev.endTime}` : ''}` : '');
                                    td.appendChild(box);
                                    box.appendChild(meta);
                                }
                            }

                            // REGULAR: render group (spanning cell) and mark occupancy
                            if (group) {
                                const span = group.ei - group.si;
                                for (let k = r; k < group.ei; k++) occupancy.get(col)[k] = true;

                                const isSingle = group.items.length === 1;
                                for (const ev of group.items) {
                                    const { rgbaBg, border } = computeColorFromLabels(ev);
                                    const box = document.createElement('div');
                                    box.className = 'slot';
                                    box.style.background = rgbaBg;
                                    box.style.borderColor = border;

                                    if (isSingle) box.style.flex = '1'; // stretch to fill rowspan height

                                    const title = document.createElement('h4');
                                    const tlink = document.createElement('a');
                                    tlink.href = ev.url || '#';
                                    tlink.target = '_blank';
                                    tlink.rel = 'noopener noreferrer';
                                    tlink.textContent = ev.title || 'Untitled';
                                    title.appendChild(tlink);
                                    box.appendChild(title);

                                    const meta = document.createElement('div');
                                    meta.className = 'meta';
                                    const assignees = (ev.assignees || '')
                                        .split(',').map(s => s.trim()).filter(Boolean)
                                        .map(u => `<a href="https://github.com/${u}" target="_blank" rel="noopener noreferrer">@${u}</a>`)
                                        .join(' ');
                                    meta.innerHTML = assignees;
                                    box.appendChild(meta);

                                    const cleanLabels = (ev.labels || [])
                                        .filter(l => l && l.name && !ACCEPTED_LABELS.has(l.name.toLowerCase()));
                                    if (cleanLabels.length) {
                                        const badges = document.createElement('div');
                                        badges.className = 'badges';
                                        cleanLabels.forEach(l => {
                                            const b = document.createElement('span');
                                            b.className = 'badge';
                                            b.textContent = l.name;
                                            badges.appendChild(b);
                                        });
                                        box.appendChild(badges);
                                    }

                                    td.appendChild(box);
                                }

                                td.setAttribute('rowspan', String(span));
                                group.used = true;
                            }

                            row.appendChild(td);
                        }

                        tbody.appendChild(row);
                    }

                    table.appendChild(tbody);
                    card.appendChild(table);
                    daysEl.appendChild(card);
                }

                if (!daysEl.children.length) {
                    daysEl.innerHTML = '<div class="day-card"><div class="day-title">No matching sessions</div></div>';
                }
            }

            daySel.addEventListener('change', render);
            typeSel.addEventListener('change', render);
            render();
        }

        load().catch(err => {
            document.getElementById('days').innerHTML =
                `<div class="day-card"><div class="day-title">Error loading schedule</div><div style="padding:12px;color:#f99;">${String(err)}</div></div>`;
            console.error(err);
        });
    </script>
</body>

</html>